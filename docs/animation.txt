# normal, size 1, left, width 1200
# insert doc_index_sidebar.txt

### Animation

## 2D Animation

SpriteSheetAnimation
Animation

## 3D Animation
    ## Actor

    For skeletal animations you can use panda3d's Actor.
    Export the model as .glft/.glb since that format support
    mesh data, texture data, animations and more, all in one file.

    # code
    from ursina import *
    from direct.actor.Actor import Actor

    app = Ursina()

    entity = Entity()
    #animations are stored within the file
    actor = Actor("filename.gltf")
    actor.reparent_to(entity)

    actor.loop("animation_name")  # use .play() instead of loop() to play it once.

    app.run()
    # text

    See the <a href="https://docs.panda3d.org/1.10/python/programming/models-and-actors/actor-animations">panda3d documentation</a> for more info.


    ## FrameAnimation3D

    FrameAnimation3d loads a sequence of models and cycles through them so it looks like it animates.
    This a memory intensive option, so it's recommended to not have very a high poly count.
    With this method you can't interpolate animations or move a single bone like you can with Actor.
    However, FrameAnimation3D is a very solid solution that is very unlikely to break or produce
    bugs like skeletal animation often can. Also, since every frame is unique, it's possible to
    adjust each frame individually.

    First, export your animation as a sequence of 3d models.
    Assuming you have a bunch of models named run_cycle_000.obj, run_cycle_001.obj, run_cycle_002.obj and so on,
    you can load the animation like this:

    #code
    FrameAnimation3d('run_cycle_')
    # text
